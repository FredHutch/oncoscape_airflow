{"_id":"json-validation","_rev":"12-385364a3a4972a64ae8131302e85b340","name":"json-validation","description":"A simple JSON validation package (subset of JSON Schema)","dist-tags":{"latest":"1.0.4"},"versions":{"1.0.0":{"name":"json-validation","description":"A simple JSON validation package (subset of JSON Schema)","version":"1.0.0","author":{"name":"Robin Berjon","email":"robin@berjon.com"},"dependencies":{"underscore":"1.3.3"},"devDependencies":{"mocha":"1.7.3","expect.js":"0.2.0"},"repository":{"type":"git","url":"git://github.com/darobin/json-validate"},"main":"lib/json-validate","readme":"\n# Overview\n\n`json-validate` is a small library that performs, shockingly enough, validation of\nJSON documents. It supports a limited subset of JSON Schema.\n\n# Installing\n\nThe usual simple:\n\n    npm install json-validate\n\nIn order to run in a browser, you simply need to include the `json-validate.js` file,\nafter having included `underscore.js` on which it depends.\n\n# Why not JSON Schema, one of the existing implementations?\n\nThe reason this library exists is because I initially needed JSON validation in a project.\nI tried to use some of the JSON Schema implementations that exist, but most were out of\ndate. Those that weren't tended to break in the contexts in which I was using them, and\nwere generally rather larger and more complex than my needs. It turned out to be simpler\nto just write a validator that matches my needs.\n\nI release this library on the assumption that if I needed it, others might too. I may\nadd support for more of JSON Schema, and I will certainly take pull requests (so long as\nthey don't cause excessive bloat).\n\nOne notable difference is that JSON Schema support schema referencing one another. Doing\nthat is an explicit non-goal of this library. But it ought to be easy to implement JSON\nreferencing separately (in another small library) and feed schemata with references \nresolved into `json-validate`.\n\n# API\n\nThe API is very simple, the following example probably tells you all you need to know:\n\n```javascript\nvar jv = new JSONValidate();\nvar result = jv.validate(object, schema);\nif (result.ok) {\n    // victory \\o/\n}\nelse {\n    console.log(\"JSON has the following errors: \" + result.errors.join(\", \") + \" at path \" + result.path);\n}\n```\n\n#### var jv = new JSONValidate()\n\nA simple constructor that takes no arguments.\n\n#### var result = jv.validate(object, schema);\n\nThis takes an object that is parsed JSON (or any in-memory equivalent) and a schema that\ncorresponds to the subset of JSON Schema described in the following section. Note that \n`validate()` will throw if you schema is invalid.\n\nThe return value is an object with the following fields:\n\n* `ok`: true if the JSON is valid, false otherwise.\n* `errors`: a list of human-readable strings describing the errors that were encountered. In\n  most cases `json-validate` will only return one single error as it does not currently try\n  to keep processing the JSON when it finds a problem, but in some cases it can return several\n  errors at once, and this is likely to increase going forward (though likely limited to finding\n  several problems with just one item). If there were no errors this array is empty.\n* `path`: a string indicating the path in the object at which the errors were found. It looks like\n  `$root.field1.field2[5]`. The idea is that if you replace `$root` with the object you passed you\n  will get to the problematic value (this is intended for human debugging though).\n\n# Supported schema constructs\n\nA schema is basically a nested structure of objects that describe the constraints on a JSON\ninstance at that nesting level. Each of these objects is keyed off a specific fundamental \n`type`, and the constraints that can be applied to the value depend on that fundamental type.\n\n### null\n\nThe object is `null`.\n\nExample schema:\n\n    { \"type\": \"null\" }\n\nNo additional constraints.\n\n### any\n\nAbsolutely anything goes here.\n\nExample schema:\n\n    { \"type\": \"any\" }\n\nNo additional constraints.\n\n### boolean\n\nThe object is a boolean value (true or false). Note that this is strictly for booleans,\nand not for values that are truthy or falsy.\n\nExample schema:\n\n    { \"type\": \"boolean\" }\n\nOther example:    \n\n    {\n        \"type\": \"boolean\"\n    ,   \"enum\": [true]\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. Since the boolean\n  type only takes two values this constraint is only ever useful if you wish to restrict\n  a value to either always being true or always being false (as in the second example above).\n\n### string\n\nThe object is a string. A number of constraints on length, patterns, and enumerations apply.\nNote that these are strictly strings and not objects that stringify.\n\nExample schemata:\n\n    { \"type\": \"string\" }\n    \n    {\n        \"type\": \"string\"\n    ,   \"enum\": [\"carrot\", \"banana\", \"donkey\"]\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"pattern\": \"a{3}\\\\d\\\\d\"\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"minLength\": 2\n    ,   \"maxLength\": 17\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be strings.\n* `pattern`: A regular expression that the string must match. Note that since it is\n  conveyed as a string you will need to escape backslashes.\n  Additional constraints:\n* `minLength` and `maxLength`: The minimal and maximal length of the string (inclusive).\n\n### number\n\nThe object is a number. It can be further constrained on enumeration, minimum, and\nmaximum values.\n\nExample schemata:\n\n    { \"type\": \"number\" }\n    \n    {\n        \"type\": \"number\"\n    ,   \"enum\": [5, 17, 23, 42]\n    }\n    \n    {\n        \"type\": \"number\"\n    ,   \"minimum\": 23\n    ,   \"exclusiveMaximum\": 57.2\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be numbers.\n* `minimum`, `maximum`, `exclusiveMinimum`, and `exclusiveMaximum`: minimal and\n  maximal boundaries on the number's value, either inclusive or exclusive.\n\n\n### object\n\nThe object is, well, an object. Its properties can be enumerated and themselves \nrecursively defined and constrained.\n\nExample schemata:\n\n    { \"type\": \"object\" }\n    \n    {\n        \"type\": \"object\"\n    ,   \"properties\": {\n            \"fullName\":  { \"type\": \"string\", \"required\": true }\n        ,   \"age\":       { \"type\": \"number\", \"minimum\": 0 }\n        ,   \"superHeroIdentity\": {\n                \"type\": \"object\"\n            ,   \"coolName\": { \"type\": \"string\" }\n            ,   \"superPower\": {\n                    \"type\": \"string\"\n                ,   \"enum\": [\"flying\", \"telekinesis\", \"parsing MIME\"]\n                }\n            }\n        }\n    }\n\nAdditional constraint:\n\n* `properties`: This is a simply an object the keys of which are those that are\n  being constrained on the object (object keys not listed here are not only allowed\n  but also unconstrained). The values for those keys are the types of the values\n  for the matching fields in JSON instances.\n\nIn addition to its regular type information, each property value can also take a\nboolean constraint called `required`. If set to true, then this field must be\npresent in the instance (the default is for it to be optional).\n\n### array\n\nThe object is an array. This can be further constrained with minimal and maximal\nlengths, as well as with constraints on the types of the objects contained in the\narray.\n\nExample schemata:\n\n    { \"type\": \"array\" }\n    \n    {\n        \"type\":         \"array\"\n    ,   \"minItems\":     3\n    ,   \"maxItems\":     200\n    ,   \"items\":        { \"type\": \"number\" }\n    ,   \"uniqueItems\":  true\n    }\n    \n    {\n        \"type\":             \"array\"\n    ,   \"items\":            [ { \"type\": \"number\" }, { \"type\": \"string\" }, { \"type\": \"string\" } ]\n    ,   \"additionalItems\":  true\n    }\n\nAdditional constraints:\n\n* `minItems` and `maxItems`: The minimal and maximal length of the array, inclusive.\n* `items` (with a type): When `items` is a type definition, then all array members will be\n  validated against that type.\n* `items` (with an array): When `items` is an array of type definitions, then the array members\n  at a given offset will be validated against the type definition at the same offset. The array\n  instance is implicitly constrained to be of the same length as the `items` constraint, unless\n  `additionalItems` is specified.\n* `additionalItems`: In the case of an array-based `items`, a boolean that allows for additional array members\n  after those constrained by the provided types. Those additional members are not validated.\n* `uniqueItems`: If true, checks that the values in the array are unique (using ===, recursively).\n\n### Union types\n\nIt is also possible to define union types, which is to say, cases in which validation will be\ntried against multiple type definitions until one matches or the list of options in the union\nis exhausted.\n\nExample schemata:\n\n    { \"type\": [\"number\", \"string\"] }\n    \n    {\n        \"type\": [\n            { \"type\": \"string\", \"pattern\": \"^\\\\w+$\" }\n        ,   { \"type\": \"array\", \"minItems\": 3 }\n        ,   \"boolean\"\n        ]\n    }\n\nA union is defined by providing an array of options for the `type`. Each item in that array may\nbe either just the string name of a fundamental type, or a full-fledged type definition. If none\nof the types match, then the validation fails.\n","_id":"json-validation@1.0.0","dist":{"shasum":"4b2b92e1bcffdb3157a07a8be927de92c5938dc1","tarball":"https://registry.npmjs.org/json-validation/-/json-validation-1.0.0.tgz"},"maintainers":[{"name":"robin.berjon","email":"robin@berjon.com"}],"directories":{}},"1.0.1":{"name":"json-validation","description":"A simple JSON validation package (subset of JSON Schema)","version":"1.0.1","author":{"name":"Robin Berjon","email":"robin@berjon.com"},"dependencies":{"underscore":"1.3.3"},"devDependencies":{"mocha":"1.7.3","expect.js":"0.2.0"},"repository":{"type":"git","url":"git://github.com/darobin/json-validation"},"main":"lib/json-validation","readme":"\n# Overview\n\n`json-validation` is a small library that performs, shockingly enough, validation of\nJSON documents. It supports a limited subset of JSON Schema.\n\n# Installing\n\nThe usual simple:\n\n    npm install json-validation\n\nIn order to run in a browser, you simply need to include the `json-validation.js` file,\nafter having included `underscore.js` on which it depends.\n\n# Why not JSON Schema, one of the existing implementations?\n\nThe reason this library exists is because I initially needed JSON validation in a project.\nI tried to use some of the JSON Schema implementations that exist, but most were out of\ndate. Those that weren't tended to break in the contexts in which I was using them, and\nwere generally rather larger and more complex than my needs. It turned out to be simpler\nto just write a validator that matches my needs.\n\nI release this library on the assumption that if I needed it, others might too. I may\nadd support for more of JSON Schema, and I will certainly take pull requests (so long as\nthey don't cause excessive bloat).\n\nOne notable difference is that JSON Schema support schema referencing one another. Doing\nthat is an explicit non-goal of this library. But it ought to be easy to implement JSON\nreferencing separately (in another small library) and feed schemata with references \nresolved into `json-validation`.\n\n# API\n\nThe API is very simple, the following example probably tells you all you need to know:\n\n```javascript\nvar jv = new JSONValidation();\nvar result = jv.validate(object, schema);\nif (result.ok) {\n    // victory \\o/\n}\nelse {\n    console.log(\"JSON has the following errors: \" + result.errors.join(\", \") + \" at path \" + result.path);\n}\n```\n\n#### var jv = new JSONValidation()\n\nA simple constructor that takes no arguments.\n\n#### var result = jv.validate(object, schema);\n\nThis takes an object that is parsed JSON (or any in-memory equivalent) and a schema that\ncorresponds to the subset of JSON Schema described in the following section. Note that \n`validate()` will throw if you schema is invalid.\n\nThe return value is an object with the following fields:\n\n* `ok`: true if the JSON is valid, false otherwise.\n* `errors`: a list of human-readable strings describing the errors that were encountered. In\n  most cases `json-validation` will only return one single error as it does not currently try\n  to keep processing the JSON when it finds a problem, but in some cases it can return several\n  errors at once, and this is likely to increase going forward (though likely limited to finding\n  several problems with just one item). If there were no errors this array is empty.\n* `path`: a string indicating the path in the object at which the errors were found. It looks like\n  `$root.field1.field2[5]`. The idea is that if you replace `$root` with the object you passed you\n  will get to the problematic value (this is intended for human debugging though).\n\n# Supported schema constructs\n\nA schema is basically a nested structure of objects that describe the constraints on a JSON\ninstance at that nesting level. Each of these objects is keyed off a specific fundamental \n`type`, and the constraints that can be applied to the value depend on that fundamental type.\n\n### null\n\nThe object is `null`.\n\nExample schema:\n\n    { \"type\": \"null\" }\n\nNo additional constraints.\n\n### any\n\nAbsolutely anything goes here.\n\nExample schema:\n\n    { \"type\": \"any\" }\n\nNo additional constraints.\n\n### boolean\n\nThe object is a boolean value (true or false). Note that this is strictly for booleans,\nand not for values that are truthy or falsy.\n\nExample schema:\n\n    { \"type\": \"boolean\" }\n\nOther example:    \n\n    {\n        \"type\": \"boolean\"\n    ,   \"enum\": [true]\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. Since the boolean\n  type only takes two values this constraint is only ever useful if you wish to restrict\n  a value to either always being true or always being false (as in the second example above).\n\n### string\n\nThe object is a string. A number of constraints on length, patterns, and enumerations apply.\nNote that these are strictly strings and not objects that stringify.\n\nExample schemata:\n\n    { \"type\": \"string\" }\n    \n    {\n        \"type\": \"string\"\n    ,   \"enum\": [\"carrot\", \"banana\", \"donkey\"]\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"pattern\": \"a{3}\\\\d\\\\d\"\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"minLength\": 2\n    ,   \"maxLength\": 17\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be strings.\n* `pattern`: A regular expression that the string must match. Note that since it is\n  conveyed as a string you will need to escape backslashes.\n  Additional constraints:\n* `minLength` and `maxLength`: The minimal and maximal length of the string (inclusive).\n\n### number\n\nThe object is a number. It can be further constrained on enumeration, minimum, and\nmaximum values.\n\nExample schemata:\n\n    { \"type\": \"number\" }\n    \n    {\n        \"type\": \"number\"\n    ,   \"enum\": [5, 17, 23, 42]\n    }\n    \n    {\n        \"type\": \"number\"\n    ,   \"minimum\": 23\n    ,   \"exclusiveMaximum\": 57.2\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be numbers.\n* `minimum`, `maximum`, `exclusiveMinimum`, and `exclusiveMaximum`: minimal and\n  maximal boundaries on the number's value, either inclusive or exclusive.\n\n\n### object\n\nThe object is, well, an object. Its properties can be enumerated and themselves \nrecursively defined and constrained.\n\nExample schemata:\n\n    { \"type\": \"object\" }\n    \n    {\n        \"type\": \"object\"\n    ,   \"properties\": {\n            \"fullName\":  { \"type\": \"string\", \"required\": true }\n        ,   \"age\":       { \"type\": \"number\", \"minimum\": 0 }\n        ,   \"superHeroIdentity\": {\n                \"type\": \"object\"\n            ,   \"coolName\": { \"type\": \"string\" }\n            ,   \"superPower\": {\n                    \"type\": \"string\"\n                ,   \"enum\": [\"flying\", \"telekinesis\", \"parsing MIME\"]\n                }\n            }\n        }\n    }\n\nAdditional constraint:\n\n* `properties`: This is a simply an object the keys of which are those that are\n  being constrained on the object (object keys not listed here are not only allowed\n  but also unconstrained). The values for those keys are the types of the values\n  for the matching fields in JSON instances.\n\nIn addition to its regular type information, each property value can also take a\nboolean constraint called `required`. If set to true, then this field must be\npresent in the instance (the default is for it to be optional).\n\n### array\n\nThe object is an array. This can be further constrained with minimal and maximal\nlengths, as well as with constraints on the types of the objects contained in the\narray.\n\nExample schemata:\n\n    { \"type\": \"array\" }\n    \n    {\n        \"type\":         \"array\"\n    ,   \"minItems\":     3\n    ,   \"maxItems\":     200\n    ,   \"items\":        { \"type\": \"number\" }\n    ,   \"uniqueItems\":  true\n    }\n    \n    {\n        \"type\":             \"array\"\n    ,   \"items\":            [ { \"type\": \"number\" }, { \"type\": \"string\" }, { \"type\": \"string\" } ]\n    ,   \"additionalItems\":  true\n    }\n\nAdditional constraints:\n\n* `minItems` and `maxItems`: The minimal and maximal length of the array, inclusive.\n* `items` (with a type): When `items` is a type definition, then all array members will be\n  validated against that type.\n* `items` (with an array): When `items` is an array of type definitions, then the array members\n  at a given offset will be validated against the type definition at the same offset. The array\n  instance is implicitly constrained to be of the same length as the `items` constraint, unless\n  `additionalItems` is specified.\n* `additionalItems`: In the case of an array-based `items`, a boolean that allows for additional array members\n  after those constrained by the provided types. Those additional members are not validated.\n* `uniqueItems`: If true, checks that the values in the array are unique (using ===, recursively).\n\n### Union types\n\nIt is also possible to define union types, which is to say, cases in which validation will be\ntried against multiple type definitions until one matches or the list of options in the union\nis exhausted.\n\nExample schemata:\n\n    { \"type\": [\"number\", \"string\"] }\n    \n    {\n        \"type\": [\n            { \"type\": \"string\", \"pattern\": \"^\\\\w+$\" }\n        ,   { \"type\": \"array\", \"minItems\": 3 }\n        ,   \"boolean\"\n        ]\n    }\n\nA union is defined by providing an array of options for the `type`. Each item in that array may\nbe either just the string name of a fundamental type, or a full-fledged type definition. If none\nof the types match, then the validation fails.\n","_id":"json-validation@1.0.1","dist":{"shasum":"5b4fc5beb35cea09c99307606b88cd46aefedf23","tarball":"https://registry.npmjs.org/json-validation/-/json-validation-1.0.1.tgz"},"maintainers":[{"name":"robin.berjon","email":"robin@berjon.com"}],"directories":{}},"1.0.2":{"name":"json-validation","description":"A simple JSON validation package (subset of JSON Schema)","version":"1.0.2","author":{"name":"Robin Berjon","email":"robin@berjon.com"},"dependencies":{"underscore":"1.3.3"},"devDependencies":{"mocha":"1.7.3","expect.js":"0.2.0"},"repository":{"type":"git","url":"git://github.com/darobin/json-validation"},"main":"lib/json-validation","readme":"\n# Overview\n\n`json-validation` is a small library that performs, shockingly enough, validation of\nJSON documents. It supports a limited subset of JSON Schema.\n\n# Installing\n\nThe usual simple:\n\n    npm install json-validation\n\nIn order to run in a browser, you simply need to include the `json-validation.js` file,\nafter having included `underscore.js` on which it depends.\n\n# Why not JSON Schema, one of the existing implementations?\n\nThe reason this library exists is because I initially needed JSON validation in a project.\nI tried to use some of the JSON Schema implementations that exist, but most were out of\ndate. Those that weren't tended to break in the contexts in which I was using them, and\nwere generally rather larger and more complex than my needs. It turned out to be simpler\nto just write a validator that matches my needs.\n\nI release this library on the assumption that if I needed it, others might too. I may\nadd support for more of JSON Schema, and I will certainly take pull requests (so long as\nthey don't cause excessive bloat).\n\nOne notable difference is that JSON Schema support schema referencing one another. Doing\nthat is an explicit non-goal of this library. But it ought to be easy to implement JSON\nreferencing separately (in another small library) and feed schemata with references \nresolved into `json-validation`.\n\n# API\n\nThe API is very simple, the following example probably tells you all you need to know:\n\n```javascript\nvar jv = new JSONValidation();\nvar result = jv.validate(object, schema);\nif (result.ok) {\n    // victory \\o/\n}\nelse {\n    console.log(\"JSON has the following errors: \" + result.errors.join(\", \") + \" at path \" + result.path);\n}\n```\n\n#### var jv = new JSONValidation()\n\nA simple constructor that takes no arguments.\n\n#### var result = jv.validate(object, schema);\n\nThis takes an object that is parsed JSON (or any in-memory equivalent) and a schema that\ncorresponds to the subset of JSON Schema described in the following section. Note that \n`validate()` will throw if you schema is invalid.\n\nThe return value is an object with the following fields:\n\n* `ok`: true if the JSON is valid, false otherwise.\n* `errors`: a list of human-readable strings describing the errors that were encountered. In\n  most cases `json-validation` will only return one single error as it does not currently try\n  to keep processing the JSON when it finds a problem, but in some cases it can return several\n  errors at once, and this is likely to increase going forward (though likely limited to finding\n  several problems with just one item). If there were no errors this array is empty.\n* `path`: a string indicating the path in the object at which the errors were found. It looks like\n  `$root.field1.field2[5]`. The idea is that if you replace `$root` with the object you passed you\n  will get to the problematic value (this is intended for human debugging though).\n\n# Supported schema constructs\n\nA schema is basically a nested structure of objects that describe the constraints on a JSON\ninstance at that nesting level. Each of these objects is keyed off a specific fundamental \n`type`, and the constraints that can be applied to the value depend on that fundamental type.\n\n### null\n\nThe object is `null`.\n\nExample schema:\n\n    { \"type\": \"null\" }\n\nNo additional constraints.\n\n### any\n\nAbsolutely anything goes here.\n\nExample schema:\n\n    { \"type\": \"any\" }\n\nNo additional constraints.\n\n### boolean\n\nThe object is a boolean value (true or false). Note that this is strictly for booleans,\nand not for values that are truthy or falsy.\n\nExample schema:\n\n    { \"type\": \"boolean\" }\n\nOther example:    \n\n    {\n        \"type\": \"boolean\"\n    ,   \"enum\": [true]\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. Since the boolean\n  type only takes two values this constraint is only ever useful if you wish to restrict\n  a value to either always being true or always being false (as in the second example above).\n\n### string\n\nThe object is a string. A number of constraints on length, patterns, and enumerations apply.\nNote that these are strictly strings and not objects that stringify.\n\nExample schemata:\n\n    { \"type\": \"string\" }\n    \n    {\n        \"type\": \"string\"\n    ,   \"enum\": [\"carrot\", \"banana\", \"donkey\"]\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"pattern\": \"a{3}\\\\d\\\\d\"\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"minLength\": 2\n    ,   \"maxLength\": 17\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be strings.\n* `pattern`: A regular expression that the string must match. Note that since it is\n  conveyed as a string you will need to escape backslashes.\n  Additional constraints:\n* `minLength` and `maxLength`: The minimal and maximal length of the string (inclusive).\n\n### number\n\nThe object is a number. It can be further constrained on enumeration, minimum, and\nmaximum values.\n\nExample schemata:\n\n    { \"type\": \"number\" }\n    \n    {\n        \"type\": \"number\"\n    ,   \"enum\": [5, 17, 23, 42]\n    }\n    \n    {\n        \"type\": \"number\"\n    ,   \"minimum\": 23\n    ,   \"exclusiveMaximum\": 57.2\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be numbers.\n* `minimum`, `maximum`, `exclusiveMinimum`, and `exclusiveMaximum`: minimal and\n  maximal boundaries on the number's value, either inclusive or exclusive.\n\n\n### object\n\nThe object is, well, an object. Its properties can be enumerated and themselves \nrecursively defined and constrained.\n\nExample schemata:\n\n    { \"type\": \"object\" }\n    \n    {\n        \"type\": \"object\"\n    ,   \"properties\": {\n            \"fullName\":  { \"type\": \"string\", \"required\": true }\n        ,   \"age\":       { \"type\": \"number\", \"minimum\": 0 }\n        ,   \"superHeroIdentity\": {\n                \"type\": \"object\"\n            ,   \"coolName\": { \"type\": \"string\" }\n            ,   \"superPower\": {\n                    \"type\": \"string\"\n                ,   \"enum\": [\"flying\", \"telekinesis\", \"parsing MIME\"]\n                }\n            }\n        }\n    }\n\nAdditional constraint:\n\n* `properties`: This is a simply an object the keys of which are those that are\n  being constrained on the object (object keys not listed here are not only allowed\n  but also unconstrained). The values for those keys are the types of the values\n  for the matching fields in JSON instances.\n\nIn addition to its regular type information, each property value can also take a\nboolean constraint called `required`. If set to true, then this field must be\npresent in the instance (the default is for it to be optional).\n\n### array\n\nThe object is an array. This can be further constrained with minimal and maximal\nlengths, as well as with constraints on the types of the objects contained in the\narray.\n\nExample schemata:\n\n    { \"type\": \"array\" }\n    \n    {\n        \"type\":         \"array\"\n    ,   \"minItems\":     3\n    ,   \"maxItems\":     200\n    ,   \"items\":        { \"type\": \"number\" }\n    ,   \"uniqueItems\":  true\n    }\n    \n    {\n        \"type\":             \"array\"\n    ,   \"items\":            [ { \"type\": \"number\" }, { \"type\": \"string\" }, { \"type\": \"string\" } ]\n    ,   \"additionalItems\":  true\n    }\n\nAdditional constraints:\n\n* `minItems` and `maxItems`: The minimal and maximal length of the array, inclusive.\n* `items` (with a type): When `items` is a type definition, then all array members will be\n  validated against that type.\n* `items` (with an array): When `items` is an array of type definitions, then the array members\n  at a given offset will be validated against the type definition at the same offset. The array\n  instance is implicitly constrained to be of the same length as the `items` constraint, unless\n  `additionalItems` is specified.\n* `additionalItems`: In the case of an array-based `items`, a boolean that allows for additional array members\n  after those constrained by the provided types. Those additional members are not validated.\n* `uniqueItems`: If true, checks that the values in the array are unique (using ===, recursively).\n\n### Union types\n\nIt is also possible to define union types, which is to say, cases in which validation will be\ntried against multiple type definitions until one matches or the list of options in the union\nis exhausted.\n\nExample schemata:\n\n    { \"type\": [\"number\", \"string\"] }\n    \n    {\n        \"type\": [\n            { \"type\": \"string\", \"pattern\": \"^\\\\w+$\" }\n        ,   { \"type\": \"array\", \"minItems\": 3 }\n        ,   \"boolean\"\n        ]\n    }\n\nA union is defined by providing an array of options for the `type`. Each item in that array may\nbe either just the string name of a fundamental type, or a full-fledged type definition. If none\nof the types match, then the validation fails.\n","_id":"json-validation@1.0.2","dist":{"shasum":"f9910db79ca5b79afe041cbbfcf24564aaa398cf","tarball":"https://registry.npmjs.org/json-validation/-/json-validation-1.0.2.tgz"},"maintainers":[{"name":"robin.berjon","email":"robin@berjon.com"}],"directories":{}},"1.0.3":{"name":"json-validation","description":"A simple JSON validation package (subset of JSON Schema)","version":"1.0.3","author":{"name":"Robin Berjon","email":"robin@berjon.com"},"dependencies":{"underscore":"1.3.3"},"devDependencies":{"mocha":"1.7.3","expect.js":"0.2.0"},"repository":{"type":"git","url":"git://github.com/darobin/json-validation"},"main":"lib/json-validation","readme":"\n# Overview\n\n`json-validation` is a small library that performs, shockingly enough, validation of\nJSON documents. It supports a limited subset of JSON Schema.\n\n# Installing\n\nThe usual simple:\n\n    npm install json-validation\n\nIn order to run in a browser, you simply need to include the `json-validation.js` file,\nafter having included `underscore.js` on which it depends.\n\n# Why not JSON Schema, one of the existing implementations?\n\nThe reason this library exists is because I initially needed JSON validation in a project.\nI tried to use some of the JSON Schema implementations that exist, but most were out of\ndate. Those that weren't tended to break in the contexts in which I was using them, and\nwere generally rather larger and more complex than my needs. It turned out to be simpler\nto just write a validator that matches my needs.\n\nI release this library on the assumption that if I needed it, others might too. I may\nadd support for more of JSON Schema, and I will certainly take pull requests (so long as\nthey don't cause excessive bloat).\n\nOne notable difference is that JSON Schema support schema referencing one another. Doing\nthat is an explicit non-goal of this library. But it ought to be easy to implement JSON\nreferencing separately (in another small library) and feed schemata with references \nresolved into `json-validation`.\n\n# API\n\nThe API is very simple, the following example probably tells you all you need to know:\n\n```javascript\nvar jv = new JSONValidation();\nvar result = jv.validate(object, schema);\nif (result.ok) {\n    // victory \\o/\n}\nelse {\n    console.log(\"JSON has the following errors: \" + result.errors.join(\", \") + \" at path \" + result.path);\n}\n```\n\n#### var jv = new JSONValidation()\n\nA simple constructor that takes no arguments.\n\n#### var result = jv.validate(object, schema);\n\nThis takes an object that is parsed JSON (or any in-memory equivalent) and a schema that\ncorresponds to the subset of JSON Schema described in the following section. Note that \n`validate()` will throw if you schema is invalid.\n\nThe return value is an object with the following fields:\n\n* `ok`: true if the JSON is valid, false otherwise.\n* `errors`: a list of human-readable strings describing the errors that were encountered. In\n  most cases `json-validation` will only return one single error as it does not currently try\n  to keep processing the JSON when it finds a problem, but in some cases it can return several\n  errors at once, and this is likely to increase going forward (though likely limited to finding\n  several problems with just one item). If there were no errors this array is empty.\n* `path`: a string indicating the path in the object at which the errors were found. It looks like\n  `$root.field1.field2[5]`. The idea is that if you replace `$root` with the object you passed you\n  will get to the problematic value (this is intended for human debugging though).\n\n# Supported schema constructs\n\nA schema is basically a nested structure of objects that describe the constraints on a JSON\ninstance at that nesting level. Each of these objects is keyed off a specific fundamental \n`type`, and the constraints that can be applied to the value depend on that fundamental type.\n\n### null\n\nThe object is `null`.\n\nExample schema:\n\n    { \"type\": \"null\" }\n\nNo additional constraints.\n\n### any\n\nAbsolutely anything goes here.\n\nExample schema:\n\n    { \"type\": \"any\" }\n\nNo additional constraints.\n\n### boolean\n\nThe object is a boolean value (true or false). Note that this is strictly for booleans,\nand not for values that are truthy or falsy.\n\nExample schema:\n\n    { \"type\": \"boolean\" }\n\nOther example:    \n\n    {\n        \"type\": \"boolean\"\n    ,   \"enum\": [true]\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. Since the boolean\n  type only takes two values this constraint is only ever useful if you wish to restrict\n  a value to either always being true or always being false (as in the second example above).\n\n### string\n\nThe object is a string. A number of constraints on length, patterns, and enumerations apply.\nNote that these are strictly strings and not objects that stringify.\n\nExample schemata:\n\n    { \"type\": \"string\" }\n    \n    {\n        \"type\": \"string\"\n    ,   \"enum\": [\"carrot\", \"banana\", \"donkey\"]\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"pattern\": \"a{3}\\\\d\\\\d\"\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"minLength\": 2\n    ,   \"maxLength\": 17\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be strings.\n* `pattern`: A regular expression that the string must match. Note that since it is\n  conveyed as a string you will need to escape backslashes.\n  Additional constraints:\n* `minLength` and `maxLength`: The minimal and maximal length of the string (inclusive).\n\n### number\n\nThe object is a number. It can be further constrained on enumeration, minimum, and\nmaximum values.\n\nExample schemata:\n\n    { \"type\": \"number\" }\n    \n    {\n        \"type\": \"number\"\n    ,   \"enum\": [5, 17, 23, 42]\n    }\n    \n    {\n        \"type\": \"number\"\n    ,   \"minimum\": 23\n    ,   \"exclusiveMaximum\": 57.2\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be numbers.\n* `minimum`, `maximum`, `exclusiveMinimum`, and `exclusiveMaximum`: minimal and\n  maximal boundaries on the number's value, either inclusive or exclusive.\n\n\n### object\n\nThe object is, well, an object. Its properties can be enumerated and themselves \nrecursively defined and constrained.\n\nExample schemata:\n\n    { \"type\": \"object\" }\n    \n    {\n        \"type\": \"object\"\n    ,   \"properties\": {\n            \"fullName\":  { \"type\": \"string\", \"required\": true }\n        ,   \"age\":       { \"type\": \"number\", \"minimum\": 0 }\n        ,   \"superHeroIdentity\": {\n                \"type\": \"object\"\n            ,   \"coolName\": { \"type\": \"string\" }\n            ,   \"superPower\": {\n                    \"type\": \"string\"\n                ,   \"enum\": [\"flying\", \"telekinesis\", \"parsing MIME\"]\n                }\n            }\n        }\n    }\n\nAdditional constraint:\n\n* `properties`: This is a simply an object the keys of which are those that are\n  being constrained on the object (object keys not listed here are not only allowed\n  but also unconstrained). The values for those keys are the types of the values\n  for the matching fields in JSON instances.\n\nIn addition to its regular type information, each property value can also take a\nboolean constraint called `required`. If set to true, then this field must be\npresent in the instance (the default is for it to be optional).\n\n### array\n\nThe object is an array. This can be further constrained with minimal and maximal\nlengths, as well as with constraints on the types of the objects contained in the\narray.\n\nExample schemata:\n\n    { \"type\": \"array\" }\n    \n    {\n        \"type\":         \"array\"\n    ,   \"minItems\":     3\n    ,   \"maxItems\":     200\n    ,   \"items\":        { \"type\": \"number\" }\n    ,   \"uniqueItems\":  true\n    }\n    \n    {\n        \"type\":             \"array\"\n    ,   \"items\":            [ { \"type\": \"number\" }, { \"type\": \"string\" }, { \"type\": \"string\" } ]\n    ,   \"additionalItems\":  true\n    }\n\nAdditional constraints:\n\n* `minItems` and `maxItems`: The minimal and maximal length of the array, inclusive.\n* `items` (with a type): When `items` is a type definition, then all array members will be\n  validated against that type.\n* `items` (with an array): When `items` is an array of type definitions, then the array members\n  at a given offset will be validated against the type definition at the same offset. The array\n  instance is implicitly constrained to be of the same length as the `items` constraint, unless\n  `additionalItems` is specified.\n* `additionalItems`: In the case of an array-based `items`, a boolean that allows for additional array members\n  after those constrained by the provided types. Those additional members are not validated.\n* `uniqueItems`: If true, checks that the values in the array are unique (using ===, recursively).\n\n### Union types\n\nIt is also possible to define union types, which is to say, cases in which validation will be\ntried against multiple type definitions until one matches or the list of options in the union\nis exhausted.\n\nExample schemata:\n\n    { \"type\": [\"number\", \"string\"] }\n    \n    {\n        \"type\": [\n            { \"type\": \"string\", \"pattern\": \"^\\\\w+$\" }\n        ,   { \"type\": \"array\", \"minItems\": 3 }\n        ,   \"boolean\"\n        ]\n    }\n\nA union is defined by providing an array of options for the `type`. Each item in that array may\nbe either just the string name of a fundamental type, or a full-fledged type definition. If none\nof the types match, then the validation fails.\n","_id":"json-validation@1.0.3","dist":{"shasum":"fcf3f5a7c1c01d95eacfc043514db774f5c77ef0","tarball":"https://registry.npmjs.org/json-validation/-/json-validation-1.0.3.tgz"},"maintainers":[{"name":"robin.berjon","email":"robin@berjon.com"}],"directories":{}},"1.0.4":{"name":"json-validation","description":"A simple JSON validation package (subset of JSON Schema)","version":"1.0.4","author":{"name":"Robin Berjon","email":"robin@berjon.com"},"dependencies":{"underscore":"1.3.3"},"devDependencies":{"mocha":"1.7.3","expect.js":"0.2.0"},"repository":{"type":"git","url":"git://github.com/darobin/json-validation"},"main":"lib/json-validation","readme":"\n# Overview\n\n`json-validation` is a small library that performs, shockingly enough, validation of\nJSON documents. It supports a limited subset of JSON Schema.\n\n# Installing\n\nThe usual simple:\n\n    npm install json-validation\n\nIn order to run in a browser, you simply need to include the `json-validation.js` file,\nafter having included `underscore.js` on which it depends.\n\n# Why not JSON Schema, one of the existing implementations?\n\nThe reason this library exists is because I initially needed JSON validation in a project.\nI tried to use some of the JSON Schema implementations that exist, but most were out of\ndate. Those that weren't tended to break in the contexts in which I was using them, and\nwere generally rather larger and more complex than my needs. It turned out to be simpler\nto just write a validator that matches my needs.\n\nI release this library on the assumption that if I needed it, others might too. I may\nadd support for more of JSON Schema, and I will certainly take pull requests (so long as\nthey don't cause excessive bloat).\n\nOne notable difference is that JSON Schema support schema referencing one another. Doing\nthat is an explicit non-goal of this library. But it ought to be easy to implement JSON\nreferencing separately (in another small library) and feed schemata with references \nresolved into `json-validation`.\n\n# API\n\nThe API is very simple, the following example probably tells you all you need to know:\n\n```javascript\nvar jv = new JSONValidation();\nvar result = jv.validate(object, schema);\nif (result.ok) {\n    // victory \\o/\n}\nelse {\n    console.log(\"JSON has the following errors: \" + result.errors.join(\", \") + \" at path \" + result.path);\n}\n```\n\n#### var jv = new JSONValidation()\n\nA simple constructor that takes no arguments.\n\n#### var result = jv.validate(object, schema);\n\nThis takes an object that is parsed JSON (or any in-memory equivalent) and a schema that\ncorresponds to the subset of JSON Schema described in the following section. Note that \n`validate()` will throw if you schema is invalid.\n\nThe return value is an object with the following fields:\n\n* `ok`: true if the JSON is valid, false otherwise.\n* `errors`: a list of human-readable strings describing the errors that were encountered. In\n  most cases `json-validation` will only return one single error as it does not currently try\n  to keep processing the JSON when it finds a problem, but in some cases it can return several\n  errors at once, and this is likely to increase going forward (though likely limited to finding\n  several problems with just one item). If there were no errors this array is empty.\n* `path`: a string indicating the path in the object at which the errors were found. It looks like\n  `$root.field1.field2[5]`. The idea is that if you replace `$root` with the object you passed you\n  will get to the problematic value (this is intended for human debugging though).\n\n# Supported schema constructs\n\nA schema is basically a nested structure of objects that describe the constraints on a JSON\ninstance at that nesting level. Each of these objects is keyed off a specific fundamental \n`type`, and the constraints that can be applied to the value depend on that fundamental type.\n\n### null\n\nThe object is `null`.\n\nExample schema:\n\n    { \"type\": \"null\" }\n\nNo additional constraints.\n\n### any\n\nAbsolutely anything goes here.\n\nExample schema:\n\n    { \"type\": \"any\" }\n\nNo additional constraints.\n\n### boolean\n\nThe object is a boolean value (true or false). Note that this is strictly for booleans,\nand not for values that are truthy or falsy.\n\nExample schema:\n\n    { \"type\": \"boolean\" }\n\nOther example:    \n\n    {\n        \"type\": \"boolean\"\n    ,   \"enum\": [true]\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. Since the boolean\n  type only takes two values this constraint is only ever useful if you wish to restrict\n  a value to either always being true or always being false (as in the second example above).\n\n### string\n\nThe object is a string. A number of constraints on length, patterns, and enumerations apply.\nNote that these are strictly strings and not objects that stringify.\n\nExample schemata:\n\n    { \"type\": \"string\" }\n    \n    {\n        \"type\": \"string\"\n    ,   \"enum\": [\"carrot\", \"banana\", \"donkey\"]\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"pattern\": \"a{3}\\\\d\\\\d\"\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"minLength\": 2\n    ,   \"maxLength\": 17\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be strings.\n* `pattern`: A regular expression that the string must match. Note that since it is\n  conveyed as a string you will need to escape backslashes.\n  Additional constraints:\n* `minLength` and `maxLength`: The minimal and maximal length of the string (inclusive).\n\n### number\n\nThe object is a number. It can be further constrained on enumeration, minimum, and\nmaximum values.\n\nExample schemata:\n\n    { \"type\": \"number\" }\n    \n    {\n        \"type\": \"number\"\n    ,   \"enum\": [5, 17, 23, 42]\n    }\n    \n    {\n        \"type\": \"number\"\n    ,   \"minimum\": 23\n    ,   \"exclusiveMaximum\": 57.2\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be numbers.\n* `minimum`, `maximum`, `exclusiveMinimum`, and `exclusiveMaximum`: minimal and\n  maximal boundaries on the number's value, either inclusive or exclusive.\n\n\n### object\n\nThe object is, well, an object. Its properties can be enumerated and themselves \nrecursively defined and constrained.\n\nExample schemata:\n\n    { \"type\": \"object\" }\n    \n    {\n        \"type\": \"object\"\n    ,   \"properties\": {\n            \"fullName\":  { \"type\": \"string\", \"required\": true }\n        ,   \"age\":       { \"type\": \"number\", \"minimum\": 0 }\n        ,   \"superHeroIdentity\": {\n                \"type\": \"object\"\n            ,   \"coolName\": { \"type\": \"string\" }\n            ,   \"superPower\": {\n                    \"type\": \"string\"\n                ,   \"enum\": [\"flying\", \"telekinesis\", \"parsing MIME\"]\n                }\n            }\n        }\n    }\n\nAdditional constraint:\n\n* `properties`: This is a simply an object the keys of which are those that are\n  being constrained on the object (object keys not listed here are not only allowed\n  but also unconstrained). The values for those keys are the types of the values\n  for the matching fields in JSON instances.\n\nIn addition to its regular type information, each property value can also take a\nboolean constraint called `required`. If set to true, then this field must be\npresent in the instance (the default is for it to be optional).\n\n### array\n\nThe object is an array. This can be further constrained with minimal and maximal\nlengths, as well as with constraints on the types of the objects contained in the\narray.\n\nExample schemata:\n\n    { \"type\": \"array\" }\n    \n    {\n        \"type\":         \"array\"\n    ,   \"minItems\":     3\n    ,   \"maxItems\":     200\n    ,   \"items\":        { \"type\": \"number\" }\n    ,   \"uniqueItems\":  true\n    }\n    \n    {\n        \"type\":             \"array\"\n    ,   \"items\":            [ { \"type\": \"number\" }, { \"type\": \"string\" }, { \"type\": \"string\" } ]\n    ,   \"additionalItems\":  true\n    }\n\nAdditional constraints:\n\n* `minItems` and `maxItems`: The minimal and maximal length of the array, inclusive.\n* `items` (with a type): When `items` is a type definition, then all array members will be\n  validated against that type.\n* `items` (with an array): When `items` is an array of type definitions, then the array members\n  at a given offset will be validated against the type definition at the same offset. The array\n  instance is implicitly constrained to be of the same length as the `items` constraint, unless\n  `additionalItems` is specified.\n* `additionalItems`: In the case of an array-based `items`, a boolean that allows for additional array members\n  after those constrained by the provided types. Those additional members are not validated.\n* `uniqueItems`: If true, checks that the values in the array are unique (using ===, recursively).\n\n### Union types\n\nIt is also possible to define union types, which is to say, cases in which validation will be\ntried against multiple type definitions until one matches or the list of options in the union\nis exhausted.\n\nExample schemata:\n\n    { \"type\": [\"number\", \"string\"] }\n    \n    {\n        \"type\": [\n            { \"type\": \"string\", \"pattern\": \"^\\\\w+$\" }\n        ,   { \"type\": \"array\", \"minItems\": 3 }\n        ,   \"boolean\"\n        ]\n    }\n\nA union is defined by providing an array of options for the `type`. Each item in that array may\nbe either just the string name of a fundamental type, or a full-fledged type definition. If none\nof the types match, then the validation fails.\n","_id":"json-validation@1.0.4","dist":{"shasum":"a9091296154d5b88a99e8dfcd27cc879cd19356c","tarball":"https://registry.npmjs.org/json-validation/-/json-validation-1.0.4.tgz"},"maintainers":[{"name":"robin.berjon","email":"robin@berjon.com"}],"directories":{}}},"readme":"\n# Overview\n\n`json-validate` is a small library that performs, shockingly enough, validation of\nJSON documents. It supports a limited subset of JSON Schema.\n\n# Installing\n\nThe usual simple:\n\n    npm install json-validate\n\nIn order to run in a browser, you simply need to include the `json-validate.js` file,\nafter having included `underscore.js` on which it depends.\n\n# Why not JSON Schema, one of the existing implementations?\n\nThe reason this library exists is because I initially needed JSON validation in a project.\nI tried to use some of the JSON Schema implementations that exist, but most were out of\ndate. Those that weren't tended to break in the contexts in which I was using them, and\nwere generally rather larger and more complex than my needs. It turned out to be simpler\nto just write a validator that matches my needs.\n\nI release this library on the assumption that if I needed it, others might too. I may\nadd support for more of JSON Schema, and I will certainly take pull requests (so long as\nthey don't cause excessive bloat).\n\nOne notable difference is that JSON Schema support schema referencing one another. Doing\nthat is an explicit non-goal of this library. But it ought to be easy to implement JSON\nreferencing separately (in another small library) and feed schemata with references \nresolved into `json-validate`.\n\n# API\n\nThe API is very simple, the following example probably tells you all you need to know:\n\n```javascript\nvar jv = new JSONValidate();\nvar result = jv.validate(object, schema);\nif (result.ok) {\n    // victory \\o/\n}\nelse {\n    console.log(\"JSON has the following errors: \" + result.errors.join(\", \") + \" at path \" + result.path);\n}\n```\n\n#### var jv = new JSONValidate()\n\nA simple constructor that takes no arguments.\n\n#### var result = jv.validate(object, schema);\n\nThis takes an object that is parsed JSON (or any in-memory equivalent) and a schema that\ncorresponds to the subset of JSON Schema described in the following section. Note that \n`validate()` will throw if you schema is invalid.\n\nThe return value is an object with the following fields:\n\n* `ok`: true if the JSON is valid, false otherwise.\n* `errors`: a list of human-readable strings describing the errors that were encountered. In\n  most cases `json-validate` will only return one single error as it does not currently try\n  to keep processing the JSON when it finds a problem, but in some cases it can return several\n  errors at once, and this is likely to increase going forward (though likely limited to finding\n  several problems with just one item). If there were no errors this array is empty.\n* `path`: a string indicating the path in the object at which the errors were found. It looks like\n  `$root.field1.field2[5]`. The idea is that if you replace `$root` with the object you passed you\n  will get to the problematic value (this is intended for human debugging though).\n\n# Supported schema constructs\n\nA schema is basically a nested structure of objects that describe the constraints on a JSON\ninstance at that nesting level. Each of these objects is keyed off a specific fundamental \n`type`, and the constraints that can be applied to the value depend on that fundamental type.\n\n### null\n\nThe object is `null`.\n\nExample schema:\n\n    { \"type\": \"null\" }\n\nNo additional constraints.\n\n### any\n\nAbsolutely anything goes here.\n\nExample schema:\n\n    { \"type\": \"any\" }\n\nNo additional constraints.\n\n### boolean\n\nThe object is a boolean value (true or false). Note that this is strictly for booleans,\nand not for values that are truthy or falsy.\n\nExample schema:\n\n    { \"type\": \"boolean\" }\n\nOther example:    \n\n    {\n        \"type\": \"boolean\"\n    ,   \"enum\": [true]\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. Since the boolean\n  type only takes two values this constraint is only ever useful if you wish to restrict\n  a value to either always being true or always being false (as in the second example above).\n\n### string\n\nThe object is a string. A number of constraints on length, patterns, and enumerations apply.\nNote that these are strictly strings and not objects that stringify.\n\nExample schemata:\n\n    { \"type\": \"string\" }\n    \n    {\n        \"type\": \"string\"\n    ,   \"enum\": [\"carrot\", \"banana\", \"donkey\"]\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"pattern\": \"a{3}\\\\d\\\\d\"\n    }\n    \n    {\n        \"type\": \"string\"\n    ,   \"minLength\": 2\n    ,   \"maxLength\": 17\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be strings.\n* `pattern`: A regular expression that the string must match. Note that since it is\n  conveyed as a string you will need to escape backslashes.\n  Additional constraints:\n* `minLength` and `maxLength`: The minimal and maximal length of the string (inclusive).\n\n### number\n\nThe object is a number. It can be further constrained on enumeration, minimum, and\nmaximum values.\n\nExample schemata:\n\n    { \"type\": \"number\" }\n    \n    {\n        \"type\": \"number\"\n    ,   \"enum\": [5, 17, 23, 42]\n    }\n    \n    {\n        \"type\": \"number\"\n    ,   \"minimum\": 23\n    ,   \"exclusiveMaximum\": 57.2\n    }\n\nAdditional constraints:\n\n* `enum`: The object must match one of the values in the `enum` array. All of these\n  must be numbers.\n* `minimum`, `maximum`, `exclusiveMinimum`, and `exclusiveMaximum`: minimal and\n  maximal boundaries on the number's value, either inclusive or exclusive.\n\n\n### object\n\nThe object is, well, an object. Its properties can be enumerated and themselves \nrecursively defined and constrained.\n\nExample schemata:\n\n    { \"type\": \"object\" }\n    \n    {\n        \"type\": \"object\"\n    ,   \"properties\": {\n            \"fullName\":  { \"type\": \"string\", \"required\": true }\n        ,   \"age\":       { \"type\": \"number\", \"minimum\": 0 }\n        ,   \"superHeroIdentity\": {\n                \"type\": \"object\"\n            ,   \"coolName\": { \"type\": \"string\" }\n            ,   \"superPower\": {\n                    \"type\": \"string\"\n                ,   \"enum\": [\"flying\", \"telekinesis\", \"parsing MIME\"]\n                }\n            }\n        }\n    }\n\nAdditional constraint:\n\n* `properties`: This is a simply an object the keys of which are those that are\n  being constrained on the object (object keys not listed here are not only allowed\n  but also unconstrained). The values for those keys are the types of the values\n  for the matching fields in JSON instances.\n\nIn addition to its regular type information, each property value can also take a\nboolean constraint called `required`. If set to true, then this field must be\npresent in the instance (the default is for it to be optional).\n\n### array\n\nThe object is an array. This can be further constrained with minimal and maximal\nlengths, as well as with constraints on the types of the objects contained in the\narray.\n\nExample schemata:\n\n    { \"type\": \"array\" }\n    \n    {\n        \"type\":         \"array\"\n    ,   \"minItems\":     3\n    ,   \"maxItems\":     200\n    ,   \"items\":        { \"type\": \"number\" }\n    ,   \"uniqueItems\":  true\n    }\n    \n    {\n        \"type\":             \"array\"\n    ,   \"items\":            [ { \"type\": \"number\" }, { \"type\": \"string\" }, { \"type\": \"string\" } ]\n    ,   \"additionalItems\":  true\n    }\n\nAdditional constraints:\n\n* `minItems` and `maxItems`: The minimal and maximal length of the array, inclusive.\n* `items` (with a type): When `items` is a type definition, then all array members will be\n  validated against that type.\n* `items` (with an array): When `items` is an array of type definitions, then the array members\n  at a given offset will be validated against the type definition at the same offset. The array\n  instance is implicitly constrained to be of the same length as the `items` constraint, unless\n  `additionalItems` is specified.\n* `additionalItems`: In the case of an array-based `items`, a boolean that allows for additional array members\n  after those constrained by the provided types. Those additional members are not validated.\n* `uniqueItems`: If true, checks that the values in the array are unique (using ===, recursively).\n\n### Union types\n\nIt is also possible to define union types, which is to say, cases in which validation will be\ntried against multiple type definitions until one matches or the list of options in the union\nis exhausted.\n\nExample schemata:\n\n    { \"type\": [\"number\", \"string\"] }\n    \n    {\n        \"type\": [\n            { \"type\": \"string\", \"pattern\": \"^\\\\w+$\" }\n        ,   { \"type\": \"array\", \"minItems\": 3 }\n        ,   \"boolean\"\n        ]\n    }\n\nA union is defined by providing an array of options for the `type`. Each item in that array may\nbe either just the string name of a fundamental type, or a full-fledged type definition. If none\nof the types match, then the validation fails.\n","maintainers":[{"name":"robin.berjon","email":"robin@berjon.com"}],"time":{"modified":"2013-02-15T15:22:00.444Z","created":"2013-01-30T17:39:28.681Z","1.0.0":"2013-01-30T17:39:29.791Z","1.0.1":"2013-01-30T17:44:20.199Z","1.0.2":"2013-01-30T17:50:42.261Z","1.0.3":"2013-02-14T13:54:28.290Z","1.0.4":"2013-02-15T15:22:00.444Z"},"author":{"name":"Robin Berjon","email":"robin@berjon.com"},"repository":{"type":"git","url":"git://github.com/darobin/json-validation"},"users":{"zzc941210":true},"_attachments":{},"_etag":"\"511e5298-e8d0\""}